# USB Power Delivery (USB PD) Specification Parser

A comprehensive Python-based parsing system that extracts and structures content from USB PD specification PDF documents into machine-readable JSONL format.

## 🎯 Project Overview

This system parses USB Power Delivery specification PDFs and produces:
- **Structured JSONL output** representing Table of Contents (ToC) hierarchy
- **Complete section extraction** with metadata preservation
- **Validation reports** comparing ToC against parsed content
- **Hierarchical data** with proper parent-child relationships

## 📋 Features

- ✅ **PDF Text Extraction** using multiple libraries (pdfplumber, PyMuPDF)
- ✅ **Table of Contents Parsing** with regex pattern matching
- ✅ **Hierarchical Section Detection** (chapters, sections, subsections)
- ✅ **JSONL Output Generation** with standardized schema
- ✅ **Validation Reporting** in Excel format
- ✅ **Semantic Tag Generation** based on content analysis
- ✅ **Robust Error Handling** and logging
- ✅ **Progress Tracking** with tqdm progress bars

## 🏗️ Project Structure

```
usb-pd-parser/
├── usb_pd_parser.py          # Main parser implementation
├── demo.py                   # Sample usage and demo script
├── requirements.txt          # Python dependencies
├── README.md                 # This file
├── sample_usb_pd_toc.jsonl   # Sample ToC output (generated by demo)
├── sample_usb_pd_metadata.json # Sample metadata (generated by demo)
└── output/                   # Generated files (after running parser)
    ├── usb_pd_toc.jsonl     # Table of Contents
    ├── usb_pd_spec.jsonl    # All sections
    ├── usb_pd_metadata.jsonl # Document metadata
    └── usb_pd_validation_report.xlsx # Validation report
```

## 🚀 Quick Start

### 1. Install Dependencies

```bash
pip install -r requirements.txt
```

### 2. Run the Demo

```bash
python demo.py
```

This creates sample data files to demonstrate the output format.

### 3. Parse Your PDF

```bash
python usb_pd_parser.py path/to/your/usb_pd_specification.pdf
```

## 📊 Output Files

### JSONL Schema

Each line in the JSONL files contains a section object with these fields:

| Field | Type | Description |
|-------|------|-------------|
| `section_id` | string | Hierarchical identifier (e.g., "2.1.2") |
| `title` | string | Section title (without numbering) |
| `page` | integer | Starting page number |
| `level` | integer | Depth level (1=chapter, 2=section, 3=subsection) |
| `parent_id` | string/null | Parent section ID (null for top level) |
| `full_path` | string | Complete section path with ID and title |
| `doc_title` | string | Document name/version |
| `tags` | array | Semantic tags for content categorization |

### Sample JSONL Entry

```json
{
  "doc_title": "USB Power Delivery Specification Rev 3.1",
  "section_id": "2.1.2",
  "title": "Power Delivery Contract Negotiation",
  "page": 53,
  "level": 3,
  "parent_id": "2.1",
  "full_path": "2.1.2 Power Delivery Contract Negotiation",
  "tags": ["contracts", "negotiation", "power"]
}
```

## 🔍 Supported Section Patterns

The parser recognizes these ToC formats:

1. **Dotted leaders**: `2.1.2 Section Title ........ 53`
2. **Simple spacing**: `2.1.2 Section Title 53`  
3. **Tab-separated**: `2.1.2\tSection Title\t53`

## 📈 Validation Report

The Excel validation report includes:

- **Summary Sheet**: Statistics comparing ToC vs parsed sections
- **ToC Sections**: Complete Table of Contents data
- **All Sections**: All parsed sections from document
- **Mismatches**: Sections missing or extra in parsing

### Validation Metrics

- Total ToC sections vs total parsed sections
- Sections found in both ToC and document
- Sections only in ToC (missing from parsing)
- Sections only in parsed output (extra detections)
- Level distribution analysis

## 🏷️ Semantic Tagging

The system automatically generates tags based on section titles:

| Keywords | Generated Tags |
|----------|----------------|
| power | ["power"] |
| contract, negotiation | ["contracts", "negotiation"] |
| communication | ["communication"] |
| cable | ["cable"] |
| device | ["devices"] |
| protocol | ["protocol"] |
| state | ["state-machine"] |
| sop | ["sop"] |

## 🛠️ Advanced Usage

### Programmatic Usage

```python
from usb_pd_parser import USBPDParser

# Initialize parser
parser = USBPDParser("usb_pd_spec.pdf")

# Process PDF
parser.process_pdf("usb_pd_spec.pdf")

# Access extracted data
toc_sections = parser.toc_sections
all_sections = parser.sections
```

### Custom Section Detection

You can extend the parser by modifying the regex patterns:

```python
parser.section_patterns.append(r'your_custom_pattern')
```

## 🔧 Configuration

### Logging Level

Modify the logging level in the script:

```python
logging.basicConfig(level=logging.DEBUG)  # For verbose output
```

### Processing Parameters

- **ToC Search Range**: First 20 pages (configurable)
- **Pattern Matching**: Multiple regex patterns for flexibility
- **Tag Generation**: Keyword-based semantic tagging

## 📝 Error Handling

The parser includes robust error handling for:

- **Missing PDF files**: Clear error messages
- **Corrupted PDFs**: Graceful degradation
- **Parsing failures**: Continue processing other sections
- **Output errors**: Detailed logging for debugging

## 🧪 Testing

Run the demo to verify installation:

```bash
python demo.py
```

Expected output:
```
✅ Sample data files created:
- sample_usb_pd_toc.jsonl
- sample_usb_pd_metadata.json

📖 USB PD Parser Usage Example:
Sample Section: 2.1.2 Power Delivery Contract Negotiation
Level: 3, Parent: 2.1
Tags: ['contracts', 'negotiation']
```

## 🤝 Contributing

To enhance the parser:

1. **Add new patterns**: Extend `section_patterns` list
2. **Improve tagging**: Modify `_generate_tags()` method
3. **Add validation rules**: Enhance `generate_validation_report()`
4. **Handle edge cases**: Update error handling logic

## 📋 Dependencies

- **pdfplumber**: PDF text extraction and layout analysis
- **PyMuPDF (fitz)**: Alternative PDF processing
- **pandas**: Data manipulation and Excel export
- **openpyxl**: Excel file creation
- **jsonlines**: JSONL file handling
- **regex**: Advanced pattern matching
- **tqdm**: Progress bar display

## 🐛 Troubleshooting

### Common Issues

1. **"PDF file not found"**: Check file path and permissions
2. **"No sections extracted"**: Verify PDF has extractable text
3. **"Pattern not matching"**: PDF may use different ToC format
4. **"Memory errors"**: Large PDFs may need processing optimization

### Debug Mode

Enable verbose logging:

```python
import logging
logging.getLogger('usb_pd_parser').setLevel(logging.DEBUG)
```

## 📊 Performance

- **Small PDFs** (< 100 pages): < 30 seconds
- **Medium PDFs** (100-500 pages): 1-3 minutes  
- **Large PDFs** (> 500 pages): 3-10 minutes

Processing time depends on:
- PDF complexity and size
- Text extraction quality
- Number of sections detected

## 📞 Support

For questions or issues:
- Review the validation report for parsing accuracy
- Check logs for detailed error information
- Verify PDF text is extractable (not scanned images)
- Ensure all dependencies are installed correctly

---

**Created**: August 2025  
**Version**: 1.0  
**License**: Open Source
